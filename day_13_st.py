# -*- coding: utf-8 -*-
"""DAY_13_ST.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kw_jszMJbW-pVtUjjP8-jkHsGJJRDnlS
"""

time=[(1,3),(2,5),(4,6),(6,7),(5,8),(7,9)]
a=[5,6,5,4,11,2]       #salaries
b=[]
b=a.copy()
for i in range(1,len(a)):
  for j in range(0,i):
    if time[j][1] <= time[i][0]:
      if b[j]+a[i]>b[i]:
        b[i]=b[j]+a[i]
print(b)
print(max(b))

def print_substrings(s):
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            print(s[i:j])
print_substrings("abcd")

def print_subsequences(s):
    n = len(s)
    # There are 2^n possible subsequences
    for i in range(1, 1 << n):
        subsequence = ''
        for j in range(n):
            # Check if the jth bit is set in i
            if i & (1 << j):
                subsequence += s[j]
        print(subsequence,end=' ')
print("Subsequences of 'abcd':")
print_subsequences("abcd")

s1='abcd'
s2='axbdc'
m=[]
l=[]
u=len(s1)
v=len(s2)
m=[]
s=""
for i in range(u+1):
  l=[0]*(v+1)
  m.append(l)
for i in range(1,u+1):
  for j in range(1,v+1):
    if s1[i-1]==s2[j-1]:
      m[i][j]=m[i-1][j-1]+1
    else:
      m[i][j]=max(m[i][j-1],m[i-1][j])
print(m[len(s1)][len(s2)])
while u!=0 and v!=0:
    if(s1[u-1]==s2[v-1]):
        s=s+s1[u-1]
        u=u-1
        v=v-1
    else:
        if(m[u][v]==m[u-1][v]):
            u=u-1
        else:
            v=v-1
s=s[::-1]
print(s)

s1='abcd'
s2='axbd'
m=[]
l=[]
u=len(s1)
v=len(s2)
m=[]
s=""
for i in range(u+1):
  l=[0]*(v+1)
  m.append(l)
for i in range(1,u+1):
  for j in range(1,v+1):
    if s1[i-1]==s2[j-1]:
      m[i][j]=m[i-1][j-1]+1
    else:
      m[i][j]=max(m[i][j-1],m[i-1][j])
print(m[len(s1)][len(s2)])
while u!=0 and v!=0:
    if(s1[u-1]==s2[v-1]):
        s=s+s1[u-1]
        u=u-1
        v=v-1
    else:
        if(m[u-1][v]>m[u][v-1]):
            u=u-1
        else:
            v=v-1
s=s[::-1]
print(s)

def trees(grid, row, col):
    rows = len(grid)
    cols = len(grid[0])
    if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0:
        return 0
    grid[row][col] = 0
    #all directions
    trees(grid, row-1, col)
    trees(grid, row+1, col)
    trees(grid, row, col-1)
    trees(grid, row, col+1)
    return 1

def rem(grid):
    c = 0
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 1:
                c += trees(grid, i, j)
    return c
grid = [[0,1,0,0,1],
        [1,0,0,1,1],
        [0,0,0,0,0],
        [1,0,0,0,0],
        [1,0,0,0,1]]
print(rem(grid))

def dfs(grid, row, col):
    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == '0':
        return
    grid[row][col] = '0'
    dfs(grid, row-1, col)
    dfs(grid, row+1, col)
    dfs(grid, row, col-1)
    dfs(grid, row, col+1)

def numIslands(grid):
    if not grid:
        return 0
    count = 0
    for row in range(len(grid)):
        for col in range(len(grid[0])):
            if grid[row][col] == '1':
                dfs(grid, row, col)
                count += 1
    return count
grid = [['0','1','0','0','1'],
        ['1','0','0','1','1'],
        ['1','0','0','0','0'],
        ['1','0','0','0','0'],
        ['1','0','0','0','1']]
print("no.of islands",numIslands(grid))

def dfs(grid, row, col):
    if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == '0':
        return 0
    # Mark the land as visited
    grid[row][col] = '0'
    # Count this cell
    area = 1
    # Visit all adjacent land and add to area
    area += dfs(grid, row-1, col)
    area += dfs(grid, row+1, col)
    area += dfs(grid, row, col-1)
    area += dfs(grid, row, col+1)
    return area

def numIslands(grid):
    if not grid:
        return 0
    count = 0
    max_area = 0
    for row in range(len(grid)):
        for col in range(len(grid[0])):
            if grid[row][col] == '1':
                # Get the area of this island
                area = dfs(grid, row, col)
                max_area = max(max_area, area)
                count += 1
    return count, max_area

grid = [['0','1','0','0','1'],
        ['1','0','0','1','1'],
        ['0','0','0','0','0'],
        ['1','0','0','0','0'],
        ['1','0','0','0','1']]
count, largest_island = numIslands(grid)
print(f"Number of islands: {count}, Largest island size: {largest_island}")

seconds=int(input())
hours = seconds // 3600
remaining_seconds = seconds % 3600
minutes = remaining_seconds // 60
seconds = remaining_seconds % 60
print(f"{hours}h:{minutes}m:{seconds}s")
 #i/p:7262 o/p:2h:1m:2s

total_days =int(input())  # Test the function with 65476 days
years = total_days // 360
remainder_after_years = total_days % 360
months = remainder_after_years // 30
remainder_after_months = remainder_after_years % 30
weeks = remainder_after_months // 6
days = remainder_after_months % 6
print(f"{years}y/{months}m/{weeks}w/{days}d")
 # 1140 3y/2m/0w/0d 360 yeras,30 months,7 weeks

l=[1,2,4,5]
r=15
c=0
for i in l:
  if r%i==0:
    c+=1
print(c)

