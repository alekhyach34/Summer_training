# -*- coding: utf-8 -*-
"""day_15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rB5QUQ95K6HutUz3axZu5AwRUHl6yuQK
"""

def print_board(board):
    for row in board:
        print(" ".join(row))
    print("\n")
def is_safe(board, row, col):
    N = len(board)
    for i in range(col):
        if board[row][i] == 'Q':
            return False
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j] == 'Q':
            return False
    for i, j in zip(range(row, N, 1), range(col, -1, -1)):
        if board[i][j] == 'Q':
            return False
    return True
def solve_n_queens_util(board, col):
    N = len(board)
    if col >= N:
        return True
    for i in range(N):
        if is_safe(board, i, col):
            board[i][col] = 'Q'
            if solve_n_queens_util(board, col + 1):
                return True
            board[i][col] = '_'
    return False
def solve_n_queens(N):
    board = [['_' for _ in range(N)] for _ in range(N)]
    if not solve_n_queens_util(board, 0):
        print("Solution does not exist")
        return False
    print_board(len(board))
    #return True
N = 6
solve_n_queens(N)

def print_board(board):
    for row in board:
        print(" ".join(row))
    print("\n")
def is_safe(board,row,col):
    N=len(board)
    for i in range(col):
        if board[row][i]=='Q':
            return False
    for i,j in zip(range(row,-1,-1),range(col,-1,-1)):
        if board[i][j]=='Q':
            return False
    for i, j in zip(range(row,N,1), range(col,-1,-1)):
        if board[i][j]=='Q':
            return False
    return True
def solve_n_queens_util(board, col):
    N=len(board)
    if col>=N:
        return True
    for i in range(N):
        if is_safe(board, i, col):
            board[i][col]='Q'
            if solve_n_queens_util(board, col + 1):
                return True
            board[i][col]='_'
    return False
def solve_n_queens(N):
    board=[['_' for _ in range(N)] for _ in range(N)]
    if not solve_n_queens_util(board, 0):
        print("Solution does not exist")
        return False
    print_board(board)
    # Count the number of Qs
    count=0
    for row in board:
        for cell in row:
            if cell=='Q':
                count+=1
    print("Number of Q's placed:",count)
    #return True
N = 6
solve_n_queens(N)

def solve_n_queen(n,board,row,col,diag,rev_diag,asf):
    if row == n:
        print(asf)
        return
    for i in range(n):
        if col[i] == 0 and diag[row+i] == 0 and rev_diag[row-i+n-1]==0:
            board[row][i] = 1
            col[i] = 1
            diag[row+i] = 1
            rev_diag[row-i+n-1]=1
            solve_n_queen(n,board,row+1,col,diag,rev_diag,asf+str(row)+'->'+str(i)+" ")
            col[i] = 0
            diag[row+i] = 0
            rev_diag[row-i+n-1]=0
def main():
    n = 5
    board = [[0 for i in range(n)] for j in range(n)]
    col = [0 for i in range(n)]
    diag = [0 for i in range(2*n-1)]
    rev_diag = [0 for i in range(2*n-1)]
    solve_n_queen(n,board,0,col,diag,rev_diag,"")
main()

def print_board(board):
    for row in board:
        print(" ".join(row))
    print("\n")
def is_safe(board, row, col):
    N = len(board)
    for i in range(col):
        if board[row][i] == 'Q':
            return False
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if (board[i][j] == 'Q') :
            return False
    for i, j in zip(range(row, N, 1), range(col, -1, -1)):
        if (board[i][j] == 'Q') :
            return False
    return True
def solve_n_queens_util(board, col):
    N = len(board)
    if col >= N:
        return True
    for i in range(N):
        if is_safe(board, i, col):
            board[i][col] = 'Q'
            if solve_n_queens_util(board, col + 1):
                return True
            board[i][col] = '_'
    return False
def solve_n_queens(N):
    board = [['_' for _ in range(N)] for _ in range(N)]
    if not solve_n_queens_util(board, 0):
        return False
    print_board(board)
    #return True
N = 6
k=1
l=2
solve_n_queens(N)

#NQueen and Rooke
def nqueen(r):
    if(r==n):
        return
    if r!=u:
      for c in range(n):
          if(check(r,c)):
              m[r][c]=1
              break
          m[r][c]=0
      return nqueen(r+1)
    else:
      nqueen(r+1)
def check(i,j):
    if(i==u):
        return 0
    elif(j==v):
        return 0
    r=i
    c=j
    for i in range(r+1):
        if(m[i][j]==1):
            return 0
    i=r
    while(i>=0 and j>=0):
        if(m[i][j]==1):
            return 0
        i=i-1
        j=j-1
    while(r>=0 and c<n):
        if(m[r][c]==1):
            return 0
        r=r-1
        c=c+1
    return 1
n=5
u=1
v=3
m=[]
for i in range(n):
    m.append([0]*n)
m[0][0]=1
nqueen(0)
print(m)

n=[3,5,9,6,8,10]
#n1=[2,5,5,5,6,7,7,7,7]
l = [0] * len(n)
r= [0]*len(n)
m=0
m1=0
s=0
for i in range(len(n)):
  if n[i]>m:
    m=n[i]
  l[i]=m
for i in range(len(n)-1,-1,-1):
  if n[i]>m1:
    m1=n[i]
  r[i]=m1
for i in range(len(n)):
  # Calculate the minimum of l[i] and r[i], then subtract n[i], and finally take the absolute value
  s=s+(abs(min(l[i],r[i]) - n[i]))
print(s)

arr=list(map(int,input().split(" ")))
l=[0]*len(arr)
r=[0]*len(arr)
m,m1=0,0
s=0
c,c1=0,0
for i in range(len(arr)):
    if arr[i]>m:
        m=arr[i]
        c+=1
    l[i]=m
for i in range(len(arr)-1,-1,-1):
    if arr[i]>m1:
        m1=arr[i]
        c1+=1
    r[i]=m1
print(set(l),set(r))
print(c,c1)

#coins
def fun():
    l1=[0]*(n+1)
    l1[0]=1
    for i in l:
        for j in range(1,n+1):
            if j>=i:
                if l1[j-i]!=0:
                    if l1[j]!=0:
                        l1[j]=min(l1[j],l1[j-i])
                    else:
                        l1[j]=l1[j-i]
    print('yes')
l=[2,3,5,6]
n=12
fun()

s1='tu5g2k1h8'
s2='g5g8gd6h3'
l=[]
s1.unique()
s2.unique()
for i in s1:
    if i in s2:
        l.append(i)
print(l)

s1='tu5g2k1h8'
s2='g5g8gd6h3'
s=set() # Initialize s as a set
for i in s1:
  if i.isdigit():
    s.add(i) # Use add() to insert elements into the set
for i in s2:
  if i.isdigit():
    s.add(i)
print(s)

d=list(sorted(s,reverse=True))
if int(d[-1])%2==0:
  print(''.join(d))
else:
  for i in range(len(d)-2,-1,-1):
    if int(d[i])%2==0:
      d.append(d.pop(i))
      print(''.join(d))
      break
    else:
      print(-1)

#coins can make sum or not
def subset(nums, target_sum):
    n=len(nums)
    l=[[0]*(tar+1) for i in range(n+1)]
    for i in range(n+1):
        l[i][0]=1
    for i in range(1,n+1):
        for j in range(1,tar+1):
            if lst[i-1]>j:
                l[i][j]=l[i-1][j]
            else:
                if l[i-1][j]==1:
                    l[i][j]=1
                elif l[i-1][j-lst[i-1]] == 1:
                    l[i][j] = 1
                else:
                    l[i][j] = 0
    return l[n][tar]
lst=[2,3,5,6]
tar=7
print(subset(lst,tar))

def rev(n, temp):
    if (n == 0):
        return temp
    return rev(n // 10,(temp * 10) + (n % 10))
n = int(input())
temp = rev(n, 0)
if (temp == n):
	print("yes")
else:
	print("no")

print('Next nearest palindrome')
def nearest_palindrome(n):
  n_str=str(n)
  if n_str==n_str[::-1]:
    return int(n_str)
  higher=int(n_str)+1
  while True:
    if str(higher)==str(higher)[::-1]:
      return higher
    higher +=1
num=int(input())
result=nearest_palindrome(num)
if num==result:
  print(num)
else:
  print(result)

